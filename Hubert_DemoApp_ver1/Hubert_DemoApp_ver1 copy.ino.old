
#include <Arduino.h>
#include <Servo.h>

//Servos
Servo body;
Servo headPan;
Servo headTilt;
Servo shoulder;
Servo elbow;
Servo gripper;

//Init position of all servos
const int servo_pins[] = {3, 5, 6, 9, 10, 11};

const int pos_init[] = {1700, 1500, 2000, 2127.5, 1485, 1600}; // E: 1650, S: 2200
int curr_pos[6];
int new_servo_val[6];
int new_pos[6];

const int pos_min[] = {560, 550, 950, 750, 550, 550};
const int pos_max[] = {2330, 2340, 2400, 2200, 2400, 2150};

const int pos_move[] = {2200, 1000, 1500, 1100, 2300, 1600};

char body_parts[] = {'B','P', 'T', 'S', 'E', 'G'};

int dv = 80;

//Servo update function
void servo_body_ex(const int new_pos) {

  int diff, steps, now, CurrPwm, NewPwm, delta = 6;

  //current servo value
  now = curr_pos[0];
  CurrPwm = now;
  NewPwm = new_pos;

  /* determine interation "diff" from old to new position */
  diff = (NewPwm - CurrPwm)/abs(NewPwm - CurrPwm); // Should return +1 if NewPwm is bigger than CurrPwm, -1 otherwise.
  steps = abs(NewPwm - CurrPwm);
  delay(10);

  for (int i = 0; i < steps; i += delta) {
    now = now + delta*diff;
    body.writeMicroseconds(now);
    delay(20);
  }
  curr_pos[0] = now;
  delay(10);
}

//Servo update function
void servo_neck_pan(const int new_pos) {

  int diff, steps, now, CurrPwm, NewPwm, delta = 6;

  //current servo value
  now = curr_pos[1];
  CurrPwm = now;
  NewPwm = new_pos;

  /* determine interation "diff" from old to new position */
  diff = (NewPwm - CurrPwm)/abs(NewPwm - CurrPwm); // Should return +1 if NewPwm is bigger than CurrPwm, -1 otherwise.
  steps = abs(NewPwm - CurrPwm);
  delay(10);

  for (int i = 0; i < steps; i += delta) {
    now = now + delta*diff;
    headPan.writeMicroseconds(now);
    delay(20);
  }
  curr_pos[1] = now;
  delay(10);
}

//Servo update function
void servo_neck_tilt(const int new_pos) {

  int diff, steps, now, CurrPwm, NewPwm, delta = 6;

  //current servo value
  now = curr_pos[2];
  CurrPwm = now;
  NewPwm = new_pos;

  /* determine interation "diff" from old to new position */
  diff = (NewPwm - CurrPwm)/abs(NewPwm - CurrPwm); // Should return +1 if NewPwm is bigger than CurrPwm, -1 otherwise.
  steps = abs(NewPwm - CurrPwm);
  delay(10);

  for (int i = 0; i < steps; i += delta) {
    now = now + delta*diff;
    headTilt.writeMicroseconds(now);
    delay(20);
  }
  curr_pos[2] = now;
  delay(10);
}

//Servo update function
void servo_shoulder(const int new_pos) {

  int diff, steps, now, CurrPwm, NewPwm, delta = 6;

  //current servo value
  now = curr_pos[3];
  CurrPwm = now;
  NewPwm = new_pos;

  /* determine interation "diff" from old to new position */
  diff = (NewPwm - CurrPwm)/abs(NewPwm - CurrPwm); // Should return +1 if NewPwm is bigger than CurrPwm, -1 otherwise.
  steps = abs(NewPwm - CurrPwm);
  delay(10);

  for (int i = 0; i < steps; i += delta) {
    now = now + delta*diff;
    shoulder.writeMicroseconds(now);
    delay(20);
  }
  curr_pos[3] = now;
  delay(10);
}

//Servo update function
void servo_elbow(const int new_pos) {

  int diff, steps, now, CurrPwm, NewPwm, delta = 6;

  //current servo value
  now = curr_pos[4];
  CurrPwm = now;
  NewPwm = new_pos;

  /* determine interation "diff" from old to new position */
  diff = (NewPwm - CurrPwm)/abs(NewPwm - CurrPwm); // Should return +1 if NewPwm is bigger than CurrPwm, -1 otherwise.
  steps = abs(NewPwm - CurrPwm);
  delay(10);

  for (int i = 0; i < steps; i += delta) {
    now = now + delta*diff;
    elbow.writeMicroseconds(now);
    delay(20);
  }
  curr_pos[4] = now;
  delay(10);
}

//Servo update function
void servo_gripper_ex(const int new_pos) {

  int diff, steps, now, CurrPwm, NewPwm, delta = 6;

  //current servo value
  now = curr_pos[5];
  CurrPwm = now;
  NewPwm = new_pos;

  /* determine interation "diff" from old to new position */
  diff = (NewPwm - CurrPwm)/abs(NewPwm - CurrPwm); // Should return +1 if NewPwm is bigger than CurrPwm, -1 otherwise.
  steps = abs(NewPwm - CurrPwm);
  delay(10);

  for (int i = 0; i < steps; i += delta) {
    now = now + delta*diff;
    gripper.writeMicroseconds(now);
    delay(20);
  }
  curr_pos[5] = now;
  delay(10);
}

void setup() {

  Serial.begin(57600); // Starts the serial communication

	//Attach each joint servo and write each init position
  body.attach(servo_pins[0]);
  body.writeMicroseconds(pos_init[0]);
  
  headPan.attach(servo_pins[1]);
  headPan.writeMicroseconds(pos_init[1]);
  
  headTilt.attach(servo_pins[2]);
  headTilt.writeMicroseconds(pos_init[2]);

  shoulder.attach(servo_pins[3]);
	shoulder.writeMicroseconds(pos_init[3]);

	elbow.attach(servo_pins[4]);
	elbow.writeMicroseconds(pos_init[4]);
	
	gripper.attach(servo_pins[5]);
  gripper.writeMicroseconds(pos_init[5]);

  //Initilize curr_pos and new_servo_val vectors
  byte i;
  for (i=0; i<(sizeof(pos_init)/sizeof(int)); i++){
    curr_pos[i] = pos_init[i];
    new_servo_val[i] = curr_pos[i];
  }

	delay(2000);
}

void move_to_init() {
  servo_body_ex(pos_init[0]);
  delay(dv);
  servo_neck_pan(pos_init[1]);
  delay(dv);
  servo_neck_tilt(pos_init[2]);
  delay(dv);
  servo_shoulder(pos_init[3]);
  delay(dv);
  servo_elbow(pos_init[4]);
  delay(dv);
  servo_gripper_ex(pos_init[5]);
  delay(dv);
}

void shoot() {
  servo_shoulder(1990);
  delay(dv);
  servo_elbow(2217);
  delay(dv);
  servo_gripper_ex(1800); // change depending on laser pointer
  delay(dv);
}

void move_one(const char X, const int position) {
  if (X == 'B') { servo_body_ex(position); delay(dv);}
  else if (X == 'P') { servo_neck_pan(position); delay(dv);} 
  else if (X == 'T') { servo_neck_tilt(position); delay(dv);} 
  else if (X == 'S') { servo_shoulder(position); delay(dv);}
  else if (X == 'E') { servo_elbow(position); delay(dv);}
  else if (X == 'G') { servo_gripper_ex(position); delay(dv);}



  // if (X == 'B') { servo_body_ex(position); delay(dv);}
  // else if (X == 'P') { servo_neck_pan(position); delay(dv);} 
  // else if (X == 'T') { servo_neck_tilt(position); delay(dv);} 
  // else if (X == 'S') { servo_shoulder(position); delay(dv);}
  // else if (X == 'E') { servo_elbow(position); delay(dv);}
  // else if (X == 'G') { servo_gripper_ex(position); delay(dv);}
}

void idle_beha(const int position) {
  servo_body_ex(position);
  delay(dv);
}

// void idle_behaviour(const int step_size) {
//   move_to_init();
//   for (int pos = pos_init[0]; pos <= pos_max[0]-100; pos += step_size) {
//     servo_body_ex(pos);
//     delay(8*dv);
//     // if (Serial.available() > 0) {
//     //   char command = Serial.read();
//     //   if (command == 'C') {
//     //     break; // Stop the loop and keep the servo in their current positions
//     //   }
//     // }
//   }
//   for (int pos = pos_max[0]-100; pos >= pos_min[0]+100; pos -= step_size) {
//     servo_body_ex(pos);
//     delay(8*dv);
//   }
//   for (int pos = pos_min[0]+100; pos <= pos_init[0]; pos += step_size) {
//     servo_body_ex(pos);
//     delay(8*dv);
//   }
// }

// void idleee() {
//     while (true) {
//       // Check if there is input from Python
//       if (Serial.available() > 0) {
//         char command = Serial.read();
//         if (command == 'C') {
//           break;  // If Python sends 'C', break out of the loop
//         }
//       }
      
//       // Perform some action here when there's no input from Python
//     }
// }

// void loop() {
//   while (true) {
//     // Check if there is input from Python
//     if (Serial.available() > 0) {
//       char command = Serial.read();
//       if (command == 'C') {
//         // If Python sends 'C', break out of the loop
//         break;
//       }
//     }
    
//     // Perform some action here when there's no input from Python
//     // Replace this comment with your code for the action you want to perform
//   }
  
//   // Code continues here after breaking out of the loop
// }

void loop() {
  if (Serial.available() > 0) {
    char command = Serial.read();
    int position = Serial.parseInt();
    Serial.println("AKN");




    if (strchr(body_parts, command)) { move_one(command, position); }
    else if (command == 'q') { move_to_init(); }
    else if (command == 's') { shoot(); }
    // else if (command == 'i') { idle_behaviour(70); }
    else if (command == 'i') { idle_beha(position); }
  }
}

